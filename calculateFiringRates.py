import sys
import numpy as np 
import matplotlib.pyplot as plt

def list_to_matrix(rows, cols, li):
    mat = np.zeros((rows, cols))
    for r in range(rows):
        start = r * cols
        end = start + cols
        mat[r] = li[start:end]
    return mat

def find_stim(line):
    for i in range(len(line)):
        if line[i] == 1:
            return i

def tuning_index(matrices):    
    tuning_indices = []

    n_nrn = len(matrices[0])
    n_stim = len(matrices)

    for nrn in range(n_nrn):
        responses = []
        for L in range(n_stim):
            responses.append(float(matrices[L][nrn])) # matrices are by stimulus: matrices[L][nrn]
        preferred = max(responses)
        other_avg = float(sum(responses) - preferred)/(n_stim-1)

        tuning_index = (preferred-other_avg)/(preferred+other_avg)
        tuning_indices.append(tuning_index)
    
    print("Tuning indices:")
    print(tuning_indices)

def find_tuning(freq_matrix, nrn):
    responses = []
    for L in range(len(freq_matrix)):
        responses.append(float(freq_matrix[L][nrn]))
    preferred = max(responses)
    return responses.index(preferred)

def connectivity_matrix(freq_matrix, weight_filename):
    # find dimensions
    n23 = len(freq_matrix[0])
    L = len(freq_matrix)

    # process weight file 
    weight_file = open(weight_filename, 'r')
    weights = weight_file.readlines()[2]
    weight_list = [float(i) for i in weights.split(',')]

    rows = n23
    cols = n23
    weight_matrix = list_to_matrix(rows, cols, weight_list) 

    # build connectivity matrix
    connect_mat = np.zeros((L, L))
    synapse_count = np.zeros((L, L))

    for pre in range(n23):
        pre_tuning = find_tuning(freq_matrix, pre)
        print("pre: %d" % pre_tuning, end='')
        for post in range(n23):
            post_tuning = find_tuning(freq_matrix, post)
            print(" post: %d" % post_tuning, end='')
            weight = weight_matrix[pre][post]
            print(" wt: %f" % weight)
            connect_mat[pre_tuning][post_tuning] += weight
            synapse_count[pre_tuning][post_tuning] += 1
    
    for r in range(L):
        np.divide(connect_mat[r], synapse_count[r])

    print(connect_mat, file=sys.stderr)
    print(synapse_count, file=sys.stderr)
    plt.matshow(connect_mat)
    plt.colorbar()
    plt.show()
    
def main():
    """ given: a file of stimuli generated by generateInput.py and a file
    of outputs generated by modelv6.py, calculates the firing rate of each neuron in response to the stimulus provided on the command line, or all stimuli if none provided. Specify layer 4 by adding --layer4 flag; assumes layer 2-3 otherwise. Calculate tuning index with -index. Calculate connectivity matrix with -con [weight matrix filename]. Prints to stdout. 
    """
    # get input
    args = sys.argv[1:]
    if len(args) < 2 or len(args) > 5: 
        print("usage: stimulus_file outputs_file [stimulus] [--layer4] [-index] [-con weights_file]")
        sys.exit(1)
     
    stim_filename = args[0]
    output_filename = args[1]

    is_layer_four = False
    one_stim_only = False
    calculate_index = False
    calculate_conmat = False

    if len(args) >= 3:
        remaining_args = len(args) - 2
        if "--layer4" in args:
            is_layer_four = True
            remaining_args -= 1
        if "-index" in args:
            calculate_index = True
            remaining_args -= 1
        if "-con" in args:
            calculate_conmat = True
            weight_filename = args[args.index("-con") + 1]
            remaining_args -= 2
        if remaining_args:
            one_stim_only = True
            stimulus = int(args[2])

    #print("Arguments: stimulus filename- %s, firing rate filename- %s, layer four: %s, one stimulus: %s, calculate index: %s, calculate matrix: %s" % (stim_filename, output_filename, str(is_layer_four), str(one_stim_only), str(calculate_index), str(calculate_conmat)), file=sys.stderr)

    # open files
    stim_file = open(stim_filename, 'r')
    output_file = open(output_filename, 'r')

    # throw out first line (and second if layer 2/3)
    output_file.readline() # total frequency line
    if not is_layer_four:
        output_file.readline() #zeroes
        output_file.readline() #has actual input, not yet recurrent
    
    # create array of firing-rate-arrays (that is, index 0 indicates stimulus 0 and index 0[0] indicates the first neuron's firing rate in response to stimulus 0)
    # get number of stimuli and neurons first
    stim_line = stim_file.readline() # corresponds w/ line of zeroes in layer 2-3
    if not is_layer_four:
        stim_line = stim_file.readline()
    stim_line = [int(i) for i in stim_line.split()]
    if one_stim_only:
        num_stimuli = 1
    else:
        num_stimuli = len(stim_line)
    
    out_line = [int(i) for i in output_file.readline().split(", ")]
    num_neurons = len(out_line)

    #print("Number of stimuli: %d, number of neurons: %d, stimulus line: %s\n firing rate line: %s" %(num_stimuli, num_neurons, str(stim_line), str(out_line)), file=sys.stderr)

    # create indexed_by_stim (indexed_by_stim[i][j] represents the number of times neuron j fired in response to stimulus i)
    indexed_by_stim = [[0 for j in range(num_neurons)] for i in range(num_stimuli)]
    
    # create num_timebins_stimulus = number of timebins each stimulus appeared in
    num_timebins_stimulus = [0 for i in range(num_stimuli)]

    # main loop
    while(stim_line and out_line[0] != ""):

        # turn the strings into lists (can't do this before checking if they're empty)
        stim_line = [int(i) for i in stim_line]
        out_line = [int(i) for i in out_line]

        # calculate which stimulus it is
        curr_stim = find_stim(stim_line)
        # print(curr_stim, end=' ', file=sys.stderr)

        num_timebins_stimulus[curr_stim] += 1

        if one_stim_only:
            if curr_stim == stimulus:
                index = 0
            else: 
                index = -1
        else:
            index = curr_stim
            
        # add 1 to the firing rate of each neuron that fired
        if index != -1:
            indexed_by_stim[index] = [indexed_by_stim[index][i] + out_line[i] for i in range(num_neurons)]

        # update lines
        stim_line = stim_file.readline().split()
        out_line = output_file.readline().split(", ")

    all_percent_fired = []
    for curr_stim in range(num_stimuli):
        # get the number of times the stimulus appeared
        curr_stim_count = float(num_timebins_stimulus[curr_stim])
        print("Stimulus %d appeared %f times" % (curr_stim, curr_stim_count), file=sys.stderr)

        # for each neuron, print the % of time it fired in response to curr_stim
        percent_fired = [str(fire_count/curr_stim_count) for fire_count in indexed_by_stim[curr_stim]]
        all_percent_fired.append(percent_fired)

        print(", ".join(percent_fired))
        #if(curr_stim == 0):
            #print(", ".join([str(i) for i in indexed_by_stim[curr_stim]]), file=sys.stderr)
    
    if calculate_index:
        tuning_index(all_percent_fired)

    if calculate_conmat:
        if is_layer_four:
            print("Error. Cannot calculate connectivity matrix for layer 4 at this time.")
        else:
            connectivity_matrix(all_percent_fired, weight_filename)

if __name__ == "__main__":
  main()