import sys
def find_stim(line):
    for i in range(len(line)):
        if line[i] == 1:
            return i

def tuning_index(matrices):    
    tuning_indices = []

    n_nrn = len(matrices[0])
    n_stim = len(matrices)

    for nrn in range(n_nrn):
        responses = []
        for L in range(n_stim):
            responses.append(float(matrices[L][nrn])) # matrices are by stimulus: matrices[L][nrn]
        preferred = max(responses)
        other_avg = float(sum(responses) - preferred)/(n_stim-1)

        tuning_index = (preferred-other_avg)/(preferred+other_avg)
        tuning_indices.append(tuning_index)
    
    print("Tuning indices:")
    print(tuning_indices)

def find_tuning(freq_matrix, nrn):
    responses = []
    for L in range(len(freq_matrix)):
        responses.append(float(freq_matrix[L][nrn]))
    preferred = max(responses)
    return responses.index(preferred)

def connectivity_matrix(freq_matrix, weight_matrix):
    #all pairs of neurons: 
        #tuning of pre = i 
        #tuning of post = i' 
        #add that to the running total in the box i-i' in the matrix
        #divide by total number to get the average strength of synapses that go from L > L' 

    #make con_mat, num_syn_mat as numpy arrays
    #for pre in range(number of neurons)
        #pre_tuning = find_tuning(pre)
        # for post in range(number of neurons)
            #post_tuning = find_tuning(post)
            #weight = weight_matrix[pre][post]
            #con_mat[pre_tuning][post_tuning] += weight
            #num_syn_mat[pre_tuning][post_tuning] += 1
    
    #for row in range(number of neurons)
        #con_mat[row].divide(num_syn_mat[row])

    #output con_mat

    print(freq_matrix)

    
def main():
    """ given: a file of stimuli generated by generateInput.py and a file
    of outputs generated by modelv6.py, calculates the firing rate of each neuron in response to the stimulus provided on the command line, or all stimuli if none provided. Specify layer 4 by adding --layer4 flag; assumes layer 2-3 otherwise. Calculate tuning index with -index. Prints to stdout. 
    """
    # get input
    args = sys.argv[1:]
    if len(args) < 2 or len(args) > 5: 
        print("usage: stimulus_file outputs_file [stimulus] [--layer4] [-index]")
        sys.exit(1)
     
    stim_filename = args[0]
    output_filename = args[1]

    is_layer_four = False
    one_stim_only = False
    calculate_index = False

    if len(args) >= 3:
        remaining_args = len(args) - 2
        if "--layer4" in args:
            is_layer_four = True
            remaining_args -= 1
        if "-index" in args:
            calculate_index = True
            remaining_args -= 1
        if remaining_args:
            one_stim_only = True
            stimulus = int(args[2])
        
    # open files
    stim_file = open(stim_filename, 'r')
    output_file = open(output_filename, 'r')

    # throw out first line (and second if layer 2/3)
    output_file.readline()
    if not is_layer_four:
        output_file.readline()
    
    # create array of firing-rate-arrays (that is, index 0 indicates stimulus 0 and index 0[0] indicates the first neuron's firing rate in response to stimulus 0)
    # get number of stimuli and neurons first
    stim_line = [int(i) for i in stim_file.readline().split()]
    if one_stim_only:
        num_stimuli = 1
    else:
        num_stimuli = len(stim_line)
    
    out_line = [int(i) for i in output_file.readline().split(", ")]
    num_neurons = len(out_line)

    # create indexed_by_stim (indexed_by_stim[i][j] represents the number of times neuron j fired in response to stimulus i)
    indexed_by_stim = [[0 for j in range(num_neurons)] for i in range(num_stimuli)]
    
    # create num_timebins_stimulus = number of timebins each stimulus appeared in
    num_timebins_stimulus = [0 for i in range(num_stimuli)]

    # main loop
    while(stim_line and out_line[0] != ""):

        # turn the strings into lists (can't do this before checking if they're empty)
        stim_line = [int(i) for i in stim_line]
        out_line = [int(i) for i in out_line]

        # calculate which stimulus it is
        curr_stim = find_stim(stim_line)

        num_timebins_stimulus[curr_stim] += 1

        if one_stim_only:
            if curr_stim == stimulus:
                index = 0
            else: 
                index = -1
        else:
            index = curr_stim


        # add 1 to the firing rate of each neuron that fired
        if index != -1:
            indexed_by_stim[index] = [indexed_by_stim[index][i] + out_line[i] for i in range(num_neurons)]

        # update lines
        stim_line = stim_file.readline().split()
        out_line = output_file.readline().split(", ")

    all_percent_fired = []
    for curr_stim in range(num_stimuli):
        # get the number of times the stimulus appeared
        curr_stim_count = float(num_timebins_stimulus[curr_stim])
        print("Stimulus %d appeared %f times" % (curr_stim, curr_stim_count), file=sys.stderr)

        # for each neuron, print the % of time it fired in response to curr_stim
        percent_fired = [str(fire_count/curr_stim_count) for fire_count in indexed_by_stim[curr_stim]]
        all_percent_fired.append(percent_fired)

        print(", ".join(percent_fired))
    
    if calculate_index:
        tuning_index(all_percent_fired)
    

if __name__ == "__main__":
  main()